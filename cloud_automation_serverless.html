<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serverless Functions - Python Cloud Automation</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" href="/favicon.png" type="image/png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <h1>‚ö° Serverless Functions: Build Event-Driven Applications</h1>
    
    <p>Serverless computing revolutionizes how we build and deploy applications - you write functions that execute in response to events, while the cloud provider handles all infrastructure, scaling, and maintenance. Like having an infinite army of workers that appear instantly when needed and disappear when done, serverless enables you to build highly scalable, cost-effective applications that respond to HTTP requests, process files, handle database changes, or react to any cloud event. Let's explore the comprehensive world of serverless functions! üî•</p>

    <h2>The Serverless Architecture</h2>
    
    <p>Think of serverless functions as specialized workers in a massive factory - each function performs a specific task, triggered by events like API calls, file uploads, database changes, or scheduled times. Using platforms like AWS Lambda, Google Cloud Functions, and Azure Functions, you can build entire applications without managing servers, automatically scaling from zero to millions of requests. Understanding event sources, execution models, and integration patterns is essential for effective serverless development!</p>

    <div class="mermaid">
    graph TB
        A[Serverless Functions] --> B[Event Sources]
        A --> C[Function Types]
        A --> D[Execution Model]
        A --> E[Integration]
        
        B --> F[HTTP/API Gateway]
        B --> G[Storage Events]
        B --> H[Database Triggers]
        B --> I[Message Queues]
        
        C --> J[Web APIs]
        C --> K[Data Processing]
        C --> L[Scheduled Tasks]
        C --> M[Webhooks]
        
        D --> N[Cold Starts]
        D --> O[Concurrency]
        D --> P[Timeouts]
        D --> Q[Memory/CPU]
        
        E --> R[Databases]
        E --> S[Storage]
        E --> T[Third-party APIs]
        E --> U[Other Functions]
        
        V[Platforms] --> W[AWS Lambda]
        V --> X[Google Cloud Functions]
        V --> Y[Azure Functions]
        V --> Z[Vercel/Netlify]
        
        style A fill:#ff6b6b
        style B fill:#51cf66
        style C fill:#339af0
        style D fill:#ffd43b
        style E fill:#ff6b6b
        style V fill:#51cf66
    </div>

    <h3>Real-World Scenario: The Serverless Application Platform üåê</h3>
    
    <p>You're building a serverless platform that handles API endpoints for web applications, processes uploaded images and videos, responds to database changes with notifications, runs scheduled data aggregations, integrates with third-party webhooks, manages authentication and authorization, processes payment transactions, and orchestrates complex workflows. Your system must handle millions of events, optimize for cost and performance, manage cold starts, and provide comprehensive monitoring. Let's build a production-ready serverless framework!</p>

    <pre><code># First, install required packages:
# pip install boto3 google-cloud-functions azure-functions requests
# pip install chalice zappa serverless-wsgi mangum fastapi

import os
import json
import base64
import logging
import time
import asyncio
from typing import Dict, Any, List, Optional, Union, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from functools import wraps
import hashlib
import uuid

# AWS Lambda
import boto3
from botocore.exceptions import ClientError

# HTTP handling
import requests
from urllib.parse import parse_qs

# Framework support
from fastapi import FastAPI, HTTPException, Request
from mangum import Mangum  # ASGI adapter for Lambda

# ==================== Serverless Configuration ====================

@dataclass
class ServerlessConfig:
    """Serverless function configuration."""
    provider: str = "aws"  # aws, gcp, azure
    runtime: str = "python3.9"
    region: str = "us-east-1"
    
    # Function settings
    timeout: int = 30  # seconds
    memory: int = 256  # MB
    
    # Concurrency
    reserved_concurrency: Optional[int] = None
    max_concurrency: int = 1000
    
    # Environment
    environment_variables: Dict[str, str] = field(default_factory=dict)
    
    # Layers and dependencies
    layers: List[str] = field(default_factory=list)
    
    # Tracing and monitoring
    enable_tracing: bool = True
    enable_logging: bool = True
    log_level: str = "INFO"
    
    # Cost optimization
    enable_auto_optimization: bool = True
    
    # Security
    vpc_config: Optional[Dict[str, Any]] = None
    iam_role: Optional[str] = None

class EventType(Enum):
    """Serverless event types."""
    HTTP = "http"
    S3 = "s3"
    DYNAMODB = "dynamodb"
    SNS = "sns"
    SQS = "sqs"
    SCHEDULE = "schedule"
    KINESIS = "kinesis"
    CLOUDWATCH = "cloudwatch"
    CUSTOM = "custom"

# ==================== Base Serverless Handler ====================

class ServerlessHandler:
    """Base class for serverless function handlers."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.logger = self._setup_logging()
        
    def _setup_logging(self):
        """Setup logging configuration."""
        logger = logging.getLogger()
        logger.setLevel(getattr(logging, self.config.log_level))
        return logger
    
    def handle(self, event: Dict[str, Any], context: Any) -> Dict[str, Any]:
        """Main handler entry point."""
        try:
            # Log event
            self.logger.info(f"Received event: {json.dumps(event)[:500]}")
            
            # Determine event type
            event_type = self._detect_event_type(event)
            
            # Route to appropriate handler
            if event_type == EventType.HTTP:
                return self.handle_http(event, context)
            elif event_type == EventType.S3:
                return self.handle_s3(event, context)
            elif event_type == EventType.DYNAMODB:
                return self.handle_dynamodb(event, context)
            elif event_type == EventType.SQS:
                return self.handle_sqs(event, context)
            elif event_type == EventType.SCHEDULE:
                return self.handle_schedule(event, context)
            else:
                return self.handle_custom(event, context)
                
        except Exception as e:
            self.logger.error(f"Handler error: {e}", exc_info=True)
            return self._error_response(str(e))
    
    def _detect_event_type(self, event: Dict[str, Any]) -> EventType:
        """Detect the type of event."""
        if 'httpMethod' in event or 'requestContext' in event:
            return EventType.HTTP
        elif 'Records' in event:
            if event['Records'][0].get('eventSource') == 'aws:s3':
                return EventType.S3
            elif event['Records'][0].get('eventSource') == 'aws:sqs':
                return EventType.SQS
            elif event['Records'][0].get('eventSource') == 'aws:dynamodb':
                return EventType.DYNAMODB
        elif 'source' in event and event['source'] == 'aws.events':
            return EventType.SCHEDULE
        else:
            return EventType.CUSTOM
    
    def handle_http(self, event: Dict[str, Any], context: Any) -> Dict[str, Any]:
        """Handle HTTP/API Gateway events."""
        return {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': 'HTTP handler not implemented'})
        }
    
    def handle_s3(self, event: Dict[str, Any], context: Any) -> Dict[str, Any]:
        """Handle S3 events."""
        for record in event['Records']:
            bucket = record['s3']['bucket']['name']
            key = record['s3']['object']['key']
            self.logger.info(f"Processing S3 object: {bucket}/{key}")
        
        return {'statusCode': 200}
    
    def handle_dynamodb(self, event: Dict[str, Any], context: Any) -> Dict[str, Any]:
        """Handle DynamoDB stream events."""
        for record in event['Records']:
            event_name = record['eventName']
            self.logger.info(f"DynamoDB event: {event_name}")
        
        return {'statusCode': 200}
    
    def handle_sqs(self, event: Dict[str, Any], context: Any) -> Dict[str, Any]:
        """Handle SQS messages."""
        for record in event['Records']:
            message = record['body']
            self.logger.info(f"Processing SQS message: {message}")
        
        return {'statusCode': 200}
    
    def handle_schedule(self, event: Dict[str, Any], context: Any) -> Dict[str, Any]:
        """Handle scheduled events."""
        self.logger.info("Running scheduled task")
        return {'statusCode': 200}
    
    def handle_custom(self, event: Dict[str, Any], context: Any) -> Dict[str, Any]:
        """Handle custom events."""
        return {'statusCode': 200}
    
    def _error_response(self, error: str) -> Dict[str, Any]:
        """Generate error response."""
        return {
            'statusCode': 500,
            'headers': {'Content-Type': 'application/json'},
            'body': json.dumps({'error': error})
        }

# ==================== AWS Lambda Functions ====================

class AWSLambdaFunction:
    """AWS Lambda function implementation."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.lambda_client = boto3.client('lambda', region_name=config.region)
        self.logger = logging.getLogger(__name__)
    
    def deploy_function(
        self,
        function_name: str,
        handler: str,
        code_zip_path: str,
        role_arn: Optional[str] = None,
        environment: Optional[Dict[str, str]] = None
    ):
        """Deploy Lambda function."""
        try:
            with open(code_zip_path, 'rb') as f:
                zip_content = f.read()
            
            function_config = {
                'FunctionName': function_name,
                'Runtime': self.config.runtime,
                'Role': role_arn or self.config.iam_role,
                'Handler': handler,
                'Code': {'ZipFile': zip_content},
                'Timeout': self.config.timeout,
                'MemorySize': self.config.memory,
                'Environment': {'Variables': environment or self.config.environment_variables}
            }
            
            # Add VPC config if specified
            if self.config.vpc_config:
                function_config['VpcConfig'] = self.config.vpc_config
            
            # Add layers if specified
            if self.config.layers:
                function_config['Layers'] = self.config.layers
            
            # Add tracing
            if self.config.enable_tracing:
                function_config['TracingConfig'] = {'Mode': 'Active'}
            
            # Create or update function
            try:
                response = self.lambda_client.create_function(**function_config)
                self.logger.info(f"Created Lambda function: {function_name}")
            except self.lambda_client.exceptions.ResourceConflictException:
                # Update existing function
                response = self.lambda_client.update_function_code(
                    FunctionName=function_name,
                    ZipFile=zip_content
                )
                self.lambda_client.update_function_configuration(
                    FunctionName=function_name,
                    Timeout=self.config.timeout,
                    MemorySize=self.config.memory,
                    Environment={'Variables': environment or {}}
                )
                self.logger.info(f"Updated Lambda function: {function_name}")
            
            return response
            
        except Exception as e:
            self.logger.error(f"Failed to deploy Lambda function: {e}")
            raise
    
    def create_api_gateway_trigger(
        self,
        function_name: str,
        api_name: str,
        stage: str = "prod"
    ):
        """Create API Gateway trigger for Lambda."""
        api_client = boto3.client('apigatewayv2', region_name=self.config.region)
        
        try:
            # Create HTTP API
            response = api_client.create_api(
                Name=api_name,
                ProtocolType='HTTP',
                Target=f"arn:aws:lambda:{self.config.region}:ACCOUNT_ID:function:{function_name}"
            )
            
            api_id = response['ApiId']
            
            # Add Lambda permission
            self.lambda_client.add_permission(
                FunctionName=function_name,
                StatementId=f"{api_name}-invoke",
                Action='lambda:InvokeFunction',
                Principal='apigateway.amazonaws.com',
                SourceArn=f"arn:aws:execute-api:{self.config.region}:ACCOUNT_ID:{api_id}/*/*"
            )
            
            self.logger.info(f"Created API Gateway trigger for {function_name}")
            return response['ApiEndpoint']
            
        except Exception as e:
            self.logger.error(f"Failed to create API Gateway trigger: {e}")
            raise

# ==================== Google Cloud Functions ====================

class GCPCloudFunction:
    """Google Cloud Functions implementation."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)
    
    def deploy_function(
        self,
        function_name: str,
        source_archive_url: str,
        entry_point: str,
        trigger_type: str = "https",
        environment: Optional[Dict[str, str]] = None
    ):
        """Deploy Google Cloud Function."""
        from google.cloud import functions_v1
        
        client = functions_v1.CloudFunctionsServiceClient()
        parent = f"projects/{self.config.project_id}/locations/{self.config.region}"
        
        function = functions_v1.CloudFunction(
            name=f"{parent}/functions/{function_name}",
            source_archive_url=source_archive_url,
            entry_point=entry_point,
            runtime=self.config.runtime,
            available_memory_mb=self.config.memory,
            timeout=f"{self.config.timeout}s",
            environment_variables=environment or self.config.environment_variables
        )
        
        # Set trigger
        if trigger_type == "https":
            function.https_trigger = functions_v1.HttpsTrigger()
        elif trigger_type == "pubsub":
            function.event_trigger = functions_v1.EventTrigger(
                event_type="google.pubsub.topic.publish",
                resource=f"projects/{self.config.project_id}/topics/{function_name}-topic"
            )
        
        # Deploy
        operation = client.create_function(parent=parent, function=function)
        result = operation.result()
        
        self.logger.info(f"Deployed Cloud Function: {function_name}")
        return result

# ==================== Azure Functions ====================

class AzureFunction:
    """Azure Functions implementation."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)
    
    def create_function_app(
        self,
        resource_group: str,
        function_app_name: str,
        storage_account: str
    ):
        """Create Azure Function App."""
        # Azure Functions deployment typically uses Azure CLI or ARM templates
        import subprocess
        
        cmd = [
            'az', 'functionapp', 'create',
            '--resource-group', resource_group,
            '--name', function_app_name,
            '--storage-account', storage_account,
            '--runtime', 'python',
            '--runtime-version', '3.9',
            '--functions-version', '4',
            '--consumption-plan-location', self.config.region
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            self.logger.info(f"Created Azure Function App: {function_app_name}")
        else:
            raise Exception(f"Failed to create Function App: {result.stderr}")

# ==================== Serverless HTTP API ====================

class ServerlessAPI:
    """Serverless HTTP API using FastAPI."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.app = FastAPI(title="Serverless API")
        self.setup_routes()
        
        # Create Lambda handler
        self.handler = Mangum(self.app)
    
    def setup_routes(self):
        """Setup API routes."""
        
        @self.app.get("/")
        async def root():
            return {"message": "Serverless API", "timestamp": datetime.now().isoformat()}
        
        @self.app.get("/health")
        async def health():
            return {"status": "healthy"}
        
        @self.app.post("/process")
        async def process_data(request: Request):
            data = await request.json()
            # Process data
            result = self._process(data)
            return {"result": result}
        
        @self.app.get("/items/{item_id}")
        async def get_item(item_id: str):
            # Fetch from database
            return {"item_id": item_id, "data": "example"}
    
    def _process(self, data: Dict[str, Any]) -> Any:
        """Process data."""
        # Implementation
        return {"processed": True, "data": data}
    
    def lambda_handler(self, event: Dict[str, Any], context: Any):
        """Lambda handler for FastAPI."""
        return self.handler(event, context)

# ==================== Serverless Data Processing ====================

class ServerlessDataProcessor:
    """Serverless data processing functions."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.s3_client = boto3.client('s3')
        self.dynamodb = boto3.resource('dynamodb')
        self.logger = logging.getLogger(__name__)
    
    def process_s3_upload(self, event: Dict[str, Any], context: Any):
        """Process uploaded S3 files."""
        for record in event['Records']:
            bucket = record['s3']['bucket']['name']
            key = record['s3']['object']['key']
            
            # Download file
            response = self.s3_client.get_object(Bucket=bucket, Key=key)
            content = response['Body'].read()
            
            # Process based on file type
            if key.endswith('.json'):
                data = json.loads(content)
                self._process_json(data, bucket, key)
            elif key.endswith('.csv'):
                self._process_csv(content, bucket, key)
            elif key.endswith(('.jpg', '.png', '.gif')):
                self._process_image(content, bucket, key)
            
            self.logger.info(f"Processed {bucket}/{key}")
        
        return {'statusCode': 200}
    
    def _process_json(self, data: Dict[str, Any], bucket: str, key: str):
        """Process JSON data."""
        # Example: Store in DynamoDB
        table = self.dynamodb.Table('processed-data')
        
        item = {
            'id': str(uuid.uuid4()),
            'source_bucket': bucket,
            'source_key': key,
            'data': data,
            'processed_at': datetime.now().isoformat()
        }
        
        table.put_item(Item=item)
    
    def _process_csv(self, content: bytes, bucket: str, key: str):
        """Process CSV data."""
        import csv
        import io
        
        # Parse CSV
        csv_data = io.StringIO(content.decode('utf-8'))
        reader = csv.DictReader(csv_data)
        
        # Process rows
        for row in reader:
            # Process each row
            pass
    
    def _process_image(self, content: bytes, bucket: str, key: str):
        """Process image files."""
        from PIL import Image
        import io
        
        # Open image
        image = Image.open(io.BytesIO(content))
        
        # Generate thumbnail
        thumbnail = image.copy()
        thumbnail.thumbnail((128, 128))
        
        # Save thumbnail
        thumbnail_buffer = io.BytesIO()
        thumbnail.save(thumbnail_buffer, format='JPEG')
        
        # Upload thumbnail
        thumbnail_key = f"thumbnails/{key}"
        self.s3_client.put_object(
            Bucket=bucket,
            Key=thumbnail_key,
            Body=thumbnail_buffer.getvalue()
        )

# ==================== Serverless Workflow Orchestration ====================

class ServerlessWorkflow:
    """Orchestrate serverless workflows."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.step_functions = boto3.client('stepfunctions')
        self.logger = logging.getLogger(__name__)
    
    def create_workflow(self, workflow_name: str, definition: Dict[str, Any]):
        """Create Step Functions workflow."""
        try:
            response = self.step_functions.create_state_machine(
                name=workflow_name,
                definition=json.dumps(definition),
                roleArn=self.config.iam_role
            )
            
            self.logger.info(f"Created workflow: {workflow_name}")
            return response['stateMachineArn']
            
        except Exception as e:
            self.logger.error(f"Failed to create workflow: {e}")
            raise
    
    def create_data_pipeline_workflow(self) -> Dict[str, Any]:
        """Create data processing pipeline workflow."""
        return {
            "Comment": "Data processing pipeline",
            "StartAt": "ValidateInput",
            "States": {
                "ValidateInput": {
                    "Type": "Task",
                    "Resource": "arn:aws:lambda:REGION:ACCOUNT:function:validate-input",
                    "Next": "ProcessData",
                    "Catch": [{
                        "ErrorEquals": ["ValidationError"],
                        "Next": "HandleError"
                    }]
                },
                "ProcessData": {
                    "Type": "Parallel",
                    "Branches": [
                        {
                            "StartAt": "ExtractData",
                            "States": {
                                "ExtractData": {
                                    "Type": "Task",
                                    "Resource": "arn:aws:lambda:REGION:ACCOUNT:function:extract-data",
                                    "End": True
                                }
                            }
                        },
                        {
                            "StartAt": "TransformData",
                            "States": {
                                "TransformData": {
                                    "Type": "Task",
                                    "Resource": "arn:aws:lambda:REGION:ACCOUNT:function:transform-data",
                                    "End": True
                                }
                            }
                        }
                    ],
                    "Next": "LoadData"
                },
                "LoadData": {
                    "Type": "Task",
                    "Resource": "arn:aws:lambda:REGION:ACCOUNT:function:load-data",
                    "Next": "SendNotification"
                },
                "SendNotification": {
                    "Type": "Task",
                    "Resource": "arn:aws:lambda:REGION:ACCOUNT:function:send-notification",
                    "End": True
                },
                "HandleError": {
                    "Type": "Task",
                    "Resource": "arn:aws:lambda:REGION:ACCOUNT:function:handle-error",
                    "End": True
                }
            }
        }

# ==================== Serverless Monitoring ====================

class ServerlessMonitoring:
    """Monitor serverless functions."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.cloudwatch = boto3.client('cloudwatch')
        self.xray = boto3.client('xray')
        self.logger = logging.getLogger(__name__)
    
    def create_alarm(
        self,
        function_name: str,
        metric_name: str,
        threshold: float,
        comparison: str = "GreaterThanThreshold"
    ):
        """Create CloudWatch alarm for function."""
        self.cloudwatch.put_metric_alarm(
            AlarmName=f"{function_name}-{metric_name}",
            ComparisonOperator=comparison,
            EvaluationPeriods=2,
            MetricName=metric_name,
            Namespace='AWS/Lambda',
            Period=300,
            Statistic='Average',
            Threshold=threshold,
            ActionsEnabled=True,
            Dimensions=[
                {'Name': 'FunctionName', 'Value': function_name}
            ]
        )
    
    def get_function_metrics(self, function_name: str) -> Dict[str, Any]:
        """Get function metrics."""
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=1)
        
        metrics = {}
        
        # Get invocation count
        response = self.cloudwatch.get_metric_statistics(
            Namespace='AWS/Lambda',
            MetricName='Invocations',
            Dimensions=[{'Name': 'FunctionName', 'Value': function_name}],
            StartTime=start_time,
            EndTime=end_time,
            Period=300,
            Statistics=['Sum']
        )
        
        if response['Datapoints']:
            metrics['invocations'] = sum(p['Sum'] for p in response['Datapoints'])
        
        # Get error count
        response = self.cloudwatch.get_metric_statistics(
            Namespace='AWS/Lambda',
            MetricName='Errors',
            Dimensions=[{'Name': 'FunctionName', 'Value': function_name}],
            StartTime=start_time,
            EndTime=end_time,
            Period=300,
            Statistics=['Sum']
        )
        
        if response['Datapoints']:
            metrics['errors'] = sum(p['Sum'] for p in response['Datapoints'])
        
        # Get duration
        response = self.cloudwatch.get_metric_statistics(
            Namespace='AWS/Lambda',
            MetricName='Duration',
            Dimensions=[{'Name': 'FunctionName', 'Value': function_name}],
            StartTime=start_time,
            EndTime=end_time,
            Period=300,
            Statistics=['Average']
        )
        
        if response['Datapoints']:
            metrics['avg_duration'] = sum(p['Average'] for p in response['Datapoints']) / len(response['Datapoints'])
        
        return metrics

# ==================== Serverless Optimization ====================

class ServerlessOptimizer:
    """Optimize serverless functions."""
    
    def __init__(self, config: ServerlessConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)
    
    def optimize_cold_starts(self) -> Dict[str, Any]:
        """Strategies to minimize cold starts."""
        return {
            'strategies': [
                {
                    'name': 'Provisioned Concurrency',
                    'description': 'Keep instances warm',
                    'implementation': self._setup_provisioned_concurrency
                },
                {
                    'name': 'Smaller Deployment Package',
                    'description': 'Reduce package size',
                    'implementation': self._optimize_package_size
                },
                {
                    'name': 'Connection Pooling',
                    'description': 'Reuse database connections',
                    'implementation': self._setup_connection_pool
                },
                {
                    'name': 'Lazy Loading',
                    'description': 'Load dependencies on demand',
                    'implementation': self._implement_lazy_loading
                }
            ]
        }
    
    def _setup_provisioned_concurrency(self, function_name: str, count: int):
        """Setup provisioned concurrency."""
        lambda_client = boto3.client('lambda')
        
        lambda_client.put_provisioned_concurrency_config(
            FunctionName=function_name,
            ProvisionedConcurrentExecutions=count,
            Qualifier='$LATEST'
        )
    
    def _optimize_package_size(self):
        """Optimize deployment package size."""
        return """
# Use Lambda layers for dependencies
# Remove unnecessary files
find . -type f -name "*.pyc" -delete
find . -type d -name "__pycache__" -delete

# Use slim base images
# Tree-shake dependencies
pip install --target ./package --no-deps package-name
"""
    
    def _setup_connection_pool(self):
        """Setup database connection pooling."""
        return """
# Global connection pool
import pymysql
from pymysql.connections import Connection

connection_pool = None

def get_connection():
    global connection_pool
    if not connection_pool:
        connection_pool = pymysql.connect(
            host='database.example.com',
            user='user',
            password='password',
            database='mydb'
        )
    return connection_pool
"""
    
    def _implement_lazy_loading(self):
        """Implement lazy loading of dependencies."""
        return """
# Lazy load heavy dependencies
def get_heavy_library():
    global heavy_lib
    if 'heavy_lib' not in globals():
        import heavy_library
        heavy_lib = heavy_library
    return heavy_lib
"""

# Example usage
if __name__ == "__main__":
    print("‚ö° Serverless Functions Examples\n")
    
    # Example 1: Initialize serverless configuration
    print("1Ô∏è‚É£ Initializing Serverless Configuration:")
    
    config = ServerlessConfig(
        provider="aws",
        runtime="python3.9",
        timeout=30,
        memory=256
    )
    
    print(f"   Provider: {config.provider}")
    print(f"   Runtime: {config.runtime}")
    print(f"   Timeout: {config.timeout}s")
    print(f"   Memory: {config.memory}MB")
    
    # Example 2: Lambda function deployment
    print("\n2Ô∏è‚É£ Deploying Lambda Function:")
    
    print("   aws_lambda = AWSLambdaFunction(config)")
    print("   aws_lambda.deploy_function(")
    print("       function_name='data-processor',")
    print("       handler='lambda_function.handler',")
    print("       code_zip_path='function.zip'")
    print("   )")
    
    # Example 3: Event types
    print("\n3Ô∏è‚É£ Serverless Event Types:")
    
    events = [
        ("HTTP/API Gateway", "RESTful APIs and webhooks"),
        ("S3", "File uploads and storage events"),
        ("DynamoDB", "Database changes and streams"),
        ("SQS", "Message queue processing"),
        ("Schedule", "Cron jobs and timers"),
        ("SNS", "Pub/Sub notifications"),
        ("Kinesis", "Stream processing")
    ]
    
    for event_type, description in events:
        print(f"   {event_type}: {description}")
    
    # Example 4: Function patterns
    print("\n4Ô∏è‚É£ Serverless Function Patterns:")
    
    patterns = [
        ("Request-Response", "Synchronous API calls"),
        ("Event Processing", "Async event handling"),
        ("Stream Processing", "Real-time data streams"),
        ("Batch Processing", "Scheduled batch jobs"),
        ("Fan-out/Fan-in", "Parallel processing"),
        ("Saga Pattern", "Distributed transactions")
    ]
    
    for pattern, use_case in patterns:
        print(f"   {pattern}: {use_case}")
    
    # Example 5: Cold start optimization
    print("\n5Ô∏è‚É£ Cold Start Optimization:")
    
    optimizations = [
        "Use smaller deployment packages",
        "Implement provisioned concurrency",
        "Reuse connections and clients",
        "Lazy load heavy dependencies",
        "Choose appropriate memory allocation",
        "Use Lambda layers for dependencies",
        "Minimize VPC usage",
        "Use compiled languages for critical paths"
    ]
    
    for optimization in optimizations:
        print(f"   ‚Ä¢ {optimization}")
    
    # Example 6: Cost optimization
    print("\n6Ô∏è‚É£ Cost Optimization Strategies:")
    
    strategies = [
        ("Right-size memory", "Optimize memory/CPU allocation"),
        ("Use ARM Graviton2", "Lower cost processors"),
        ("Implement caching", "Reduce function invocations"),
        ("Batch processing", "Process multiple items per invocation"),
        ("Use Step Functions", "Orchestrate workflows efficiently"),
        ("Set up cost alerts", "Monitor spending")
    ]
    
    for strategy, description in strategies:
        print(f"   {strategy}: {description}")
    
    # Example 7: Monitoring metrics
    print("\n7Ô∏è‚É£ Key Monitoring Metrics:")
    
    metrics = [
        "Invocation count",
        "Error rate",
        "Duration (avg, p50, p99)",
        "Concurrent executions",
        "Throttles",
        "Dead letter queue messages",
        "Cold starts",
        "Cost per invocation"
    ]
    
    for metric in metrics:
        print(f"   üìä {metric}")
    
    # Example 8: Security best practices
    print("\n8Ô∏è‚É£ Serverless Security:")
    
    security = [
        "üîê Use least privilege IAM roles",
        "üîë Store secrets in Secrets Manager",
        "üõ°Ô∏è Enable VPC for network isolation",
        "üìù Implement input validation",
        "üîç Enable X-Ray tracing",
        "üìä Set up CloudWatch alarms",
        "üö´ Implement rate limiting",
        "‚úÖ Regular security audits"
    ]
    
    for practice in security:
        print(f"   {practice}")
    
    # Example 9: Testing strategies
    print("\n9Ô∏è‚É£ Testing Serverless Functions:")
    
    testing = [
        ("Unit Tests", "Test business logic"),
        ("Integration Tests", "Test with real services"),
        ("Local Testing", "Use SAM or Serverless Framework"),
        ("Load Testing", "Test scalability"),
        ("Chaos Testing", "Test failure scenarios")
    ]
    
    for test_type, purpose in testing:
        print(f"   {test_type}: {purpose}")
    
    # Example 10: Frameworks and tools
    print("\nüîü Serverless Frameworks:")
    
    frameworks = [
        ("Serverless Framework", "Multi-cloud deployment"),
        ("SAM (AWS)", "AWS-native framework"),
        ("Chalice", "Python framework for AWS"),
        ("Zappa", "Django/Flask on Lambda"),
        ("Vercel", "Frontend and API functions"),
        ("Netlify Functions", "JAMstack functions")
    ]
    
    for framework, description in frameworks:
        print(f"   {framework}: {description}")
    
    print("\n‚úÖ Serverless functions demonstration complete!")
    print("\nüìù Note: Remember that serverless is about:")
    print("   ‚Ä¢ No server management")
    print("   ‚Ä¢ Automatic scaling")
    print("   ‚Ä¢ Pay per execution")
    print("   ‚Ä¢ Event-driven architecture")
    print("   ‚Ä¢ Focus on business logic")
</code></pre>

    <h2>Key Takeaways and Best Practices üéØ</h2>
    
    <ul>
        <li><strong>Optimize Cold Starts:</strong> Minimize package size and use provisioned concurrency.</li>
        
        <li><strong>Handle Events Properly:</strong> Parse and validate event data correctly.</li>
        
        <li><strong>Implement Error Handling:</strong> Use try-catch and dead letter queues.</li>
        
        <li><strong>Monitor Everything:</strong> Track metrics, logs, and traces.</li>
        
        <li><strong>Manage State Externally:</strong> Functions should be stateless.</li>
        
        <li><strong>Use Appropriate Timeouts:</strong> Set realistic timeout values.</li>
        
        <li><strong>Implement Idempotency:</strong> Handle duplicate events gracefully.</li>
        
        <li><strong>Secure Functions:</strong> Use least privilege IAM and encrypt data.</li>
    </ul>

    <h3>Serverless Best Practices üìã</h3>
    
    <div class="comment-block">
        <p><strong>Pro Tip:</strong> Think of serverless functions as specialized workers that appear when needed and disappear when done - design them to be fast, focused, and fault-tolerant. Keep functions small and single-purpose - each should do one thing well. Optimize for cold starts by minimizing dependencies and using layers for shared code. Always handle events idempotently since they might be delivered multiple times. Use environment variables for configuration but Secrets Manager for sensitive data. Implement proper error handling with retries and dead letter queues. Monitor everything - invocations, errors, duration, and costs. Use X-Ray for distributed tracing to understand performance bottlenecks. Design for failure - functions can timeout, throttle, or fail. Use Step Functions for complex workflows instead of chaining Lambda functions. Cache frequently accessed data to reduce latency and costs. Test locally with SAM or Serverless Framework before deploying. Set up cost alerts early - serverless can scale infinitely, including costs! Most importantly: embrace event-driven architecture - think in terms of events and reactions, not servers and processes!</p>
    </div>
    
    <p>Mastering serverless functions enables you to build highly scalable, cost-effective applications without managing infrastructure. You can now create event-driven architectures, process data streams, build APIs, run scheduled tasks, and orchestrate complex workflows all with automatic scaling and pay-per-use pricing. Whether you're building microservices, data pipelines, or full applications, serverless empowers you to focus on code, not servers! üöÄ</p>
    
    <footer>
        <p>Next up: <a href="cloud_automation_storage.html">Cloud Storage Management - Master Data in the Cloud!</a></p>
    </footer>
</body>
</html>